<h1>Отчёт:</h1> 

**Задача:**

Создать программу работы со стеком,выполняющую операции добавления, удаления элементов и вывод текущего
состояния стека. Реализовать стек: а)массивом; б) списком. Все стандартные операции со стеком должны быть оформлены
подпрограммами. При реализации стека списком в вывод текущего состояния стека добавить просмотр адресов элементов стека
и создать свой список или массив свободных областей(адресов освобождаемых элементов) с выводом его на экран.
Элементами стека являются слова.
Распечатайте слова в обратном порядке.

**Цель работы** 

Реализовать операции работы со стеком, который
представлен в виде массива (статического или динамического) и в виде
односвязного списка, оценить преимущества и недостатки каждой реализации,
получить представление о механизмах выделения и освобождения памяти при
работе с динамическими структурами данных.

**Введение:**

Наименование программы: lab_04.c

Краткие характеристики: Программа симулирует работу стека

Срок сдачи: 10.10.19  

**Основания для разработки:**

Заказчик: Александра Васильевна Силантьева

Заказчик: Никульшина Татьяна Александровна

Исполнитель: Сукочева Элис

**Требования к программе:**

1. Задача решается на языке программирования "с". 

2. При некорректном вводе пользователя выводится сообщение об ошибке и просьба ввести заново.

3. При переполнении стека выдавать сообщение "stack overflow".

4. При попытке удалить элемент в пустом стеке, выдавать сообщение "stack underflow".

**Требования к функциональным характеристикам:**

1. Постановка задачи: 
Задача заключается в том, чтобы обработать, введённые пользователем слова. Т.е. записывать слова в массив и список. Удалять слова по его просьбе.
Контролировать список свободных областей. Сравнить время и эффективность разных реализаций стека. Вывести слова в обратном порядке.

**Входные данные**

1. Цифра, которая указывает на пункт меню, который необходимо выполнить.

2. Информационные данные: 

   1. Числа, определяющие какой-то выбор (Например выбор из какого текстового файла считывать.)

   2. Строкa ,слова которой будут записаны в стек.)

4. Файл, в котором лежат слова

**Выходные данные**

1. Список.

2. Массив.

3. Слова в обратном порядке.

4. Массив свободных областей.

5. Время push и pop.


**Структура данных.**

```

typedef struct stack_s
{
    char word[MAX_LEN_WORD];
    struct stack_s *next;
} stack_s;

typedef struct
{
    stack_s *array[MAX_LEN_ARRAY_FREE];
    int len;
} free_struct;

typedef struct
{
    char word[MAX_COUNT_WORD][MAX_LEN_WORD];
    int size;
} array_stack_s;

```

Основные две структуры данных, используемые в программе – массив и список

Массив (array_stack_s) имеет следующие поля:

1. Массив слов.

2. Количество слов.

Список (stack_s) имеет поля:

1. Массив символов для хранения слова.

2. Указатель на следующий узел.

Также имеется массив (free_struct) свободных областей, который имеет следующие поля:

1. Maccив свободных адресов. 

2. Количество свободных адресов.

**Выбор действия**

```

 1. Добавить слово. 

 2. Удалить слово. 
 
 3. Вывод текущего состояния стека. 
 
 4. Вывести массив свободных областей. 
 
 5. Распечатать слова в обратном порядке. 
 
 6. Очистить список. 
 
 7. Очистить массив. 
 
 8. Сравнить время. 
 
 0. Выход.

 ```

**Тестовые данные**

1. Тесты для главного меню:

| Входные данные | Выходные данные | Проверяется |  
|------------|----------|----------|
|1|Просьба ввести слово|Корректная работа|
|2|Сообщение о удалении слова|Корректная работа|
|3|Вывод текущего состояния стека.|Корректная работа|
|4|массив свободных областей.|Корректная работа|
|6|Сообщение об очищение списка|Корректная работа|
|7|Сообщение об очищение массива|Корректная работа|
|8|Время|Корректная работа|
|8|Вывод сообщения, о завершении программы|Корректная работа|

2. Тесты для вывода текущего состояния стека. 

| Входные данные | Выходные данные | 
|------------|----------|
|Стек пуст||
|В стеке одно слово|одно слово и его адрес|
|Стек со словами|Стек со словами и адресами|

3. Тесты для вывода массива свободных областей.

| Входные данные | Выходные данные | 
|------------|----------|
|Массив пуст|Сообщение о том, что массив пуст|
|В массиве один адрес|Один адрес|
|Массив с адресами|Массив с адресами|


**Итоги и расчёты**

Файл из 500 слов:

![image](uploads/509a106307cd2cf96cd6a1279591250b/image.png)


![image](uploads/c4e05adcecfd8436c7bca9841e489ef2/image.png)


![image](uploads/9bbf3ff80b7c3aba70ce4286db0a8b61/image.png)



Файл из 50 000 слов:

![image](uploads/ae3a434dc53188f3a5b9eac0a7af8e53/image.png)

![image](uploads/28f74facc60503c4f1c8515e3284afe6/image.png)

![image](uploads/77ce11390f40d14076d0a3390291c14d/image.png)


Из сравнения алгоритмов видно, что куда эффективнее использовать массив, нежели список для работы со стеком.

**Вывод**



В процессе реализации данной программы, мы поняли, что по скорости всегда будет быстрее реализация в виде массива, но, если говорить о памяти, то, если нам заранее известно примерное кол-во элементов и массив заполнен более чем на 50 процентов, то выгоднее использовать его, иначе список.


**Ответы на вопросы**

1. Что такое стек?

Стек – это последовательный список с переменной длиной, в котором
включение и исключение элементов происходит только с одной стороны – с его
вершины. Стек функционирует по принципу: последним пришел – первым ушел,
Last In – First Out (LIFO).

2. Сколько памяти выделяется под хранение стека при
различной его реализации?

При реализации стека в виде вектора выделяется фиксированное количество памяти.

При реализации стека в виде списка объём памяти зависит от 
объема доступной программе оперативной памяти.

3. Каким образом освобождается память при удалении элемента стека при
различной реализации стека?

При реализации стека в виде массива память освобождается при выходе из программы.

При реализации стека в виде списка каждый раз при удалении элемента.

4. Что происходит с элементами стека при его просмотре?

Они уходят из стека.

5. Каким образом эффективнее реализовывать стек? От чего это зависит?

Если мы говорим о скорости, то выгоднее реализовывать в виде массива.

Если мы говорим о списке, то при заполненности менее 50% выгоднее использовать список, иначе массив.

