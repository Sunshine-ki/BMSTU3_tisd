<h1>Отчёт:</h1> 

**Задача:**

Смоделировать операцию умножения действительного числа на действительное число в форме +/- m.n E +/- K, где суммарная длина мантиссы (m+n) - до 30 значащих цифр, а величина порядка K - до 5 цифр. Результат выдать в форме +/-0.m1 E +/- K1, где m1 - до 30 значащих цифр, а K2 - до 5 цифр.

**Введение:**

Наименование программы: lab_01.c

Краткие характеристики: Программа служит для перемножения двух действительных чисел.

Ввод может осуществляться как в экспоненциальном формате, так и в вещественном. Пользователь сам решает, когда завершиться программа. Обработка ошибок присутствует.

Срок сдачи: 16.09.19  

**Основания для разработки:**

Заказчик: Александра Васильевна Силантьева

Исполнитель: Сукочева Элис

**Требования к программе:**

1. Задача решается на языке программирования "с". 

2. При некорректном вводе пользователя выводится сообщение об ошибке и просьба ввести заново.

3. При суммарной длине мантиссы больше 30 цифр происходит округление. (Допустимые потери данных)

4. При порядке длинной более 5 цифр выдаётся сообщение об ошибке. (Слишком большое число)


**Требования к функциональным характеристикам:**

1. Постановка задачи: 
Задача заключается в том, чтобы обработать, введённые пользователем числа, на ошибки и корректность записи.
Далее проверить, суммарную длину мантиссы и порядок и выдать результат умножения. Также позволить пользователю прочесть инструкцию. Следить за регистром (ответ не зависит от регистра).

2. Типы входных и выходных данных:

| Входные данные | Результат работы программы | 
|------------|----------| 
|Верный ввод двух чисел| Верный результат их перемножения | 
|Неверный ввод|Сообщение о некорректном вводе и просьба ввести заново|

*Неверный ввод подразумевает под собой:

1. Некорректные символы в числе (отличные от цифр, точки и символа "e")

2. На вопрос о желании узнать информацию корректный ответ только: yes/no (ответ не зависит от регистра).

3. Программа завершается как только пользователь введёт "exit". (ответ не зависит от регистра)

4. Программа выдаёт результат каждый раз, когда пользователь вводит два корректных числа, удовлетворяющих инструкции.

**Тестовые данные**

Функциональные тесты:

Тепличные:

| Входные данные | Выходные данные | Проверяется |  
|------------|----------|----------|
|2.0 6.0|0.12е2|Корректность умножения|
|-2.0 -6.0|0.12е2|Корректность умножения знаков - на -|
|2.0 -6.0|-0.12е2|Корректность умножения знаков + на -|
|-2.0 6.0|-0.12е2|Корректность умножения знаков - на +|
|1.2e2 1.2e2|0.144e5|Корректность умножения экспонециальных чисел| 
|1.2e2 120|0.144e5|Корректность умножения экспон. на веществен.|
|123.123 123.123|0.12159273129е5|Умножения больших чисел|
|exit|Завершение программы.|Корректность завершения программы|
|EXIT|Завершение программы.|Завершение программы с учётом регистра|

Граничные:

| Входные данные | Выходные данные | Проверяется |  
|------------|----------|----------|
|0.00000 0.00000|0.0е0|Нулевое значение в вещественном формате|
|0.0e1000 0.0e1000|0.0е|Нулевое значение в эксп. формате|
|0.1e99999 1.0e-99999|0.1e0|Порядок первого + порядок второго = 0|
|Отсутствие данных|Просьба ввести данные|

Запредельные:

| Входные данные | Выходные данные | 
|------------|----------| 
|1231ewe21|Некорректные символы!|
|123e.21|'e' идёт после '.'|
|+123.1221|Пишите без знака "+"|
|12.12e+122|Пишите без знака "+"|
|-1221.e-12-12|Слишком много знаков '-'|
|dfdwe|Некорректные символы!|
|1221331|'.' встретилась 0 раз!|
|123123e10|'.' встретилась 0 раз!|
|12312.e2121|Недопустимый формат!|
|1212.12e000021|После "e" не должно быть нулей!|
|0.1e123456|Слишком большой порядок|
|0.1e-123456|Слишком большой порядок|
|0.999999999999998000000000000001e123456|Слишком большой порядок|
|0.0.0.0|"." встретилась более 1 раза!|
|0.2e33e3|"E" встретилась более 1 раза!|


**СД**

Структурой данных является структура, содержащая:

1. Массив чисел (мантисса) (int)

2. Знак числа (int)

3. Порядок (е) (int)

5. Позицию точки. (int)

```

// Структура, содержащая характеристики числа
typedef struct 
{
	int sign_number; // Знак числа (0:+ 1:-) 
	int mantissa[LEN]; // Мантисса числа
	int power; // Позицию точки
	int exp; // Порядок числа  
} number_attributes;

```

**Описание алгоритмов:**

**1. float_to_number**

int float_to_number(char str_number[LEN], number_attributes *number)

Предназначение: 

Переводит строку чисел, записанных в вещественной форме в массив чисел

Входные данные:

1. Строка, содержащая число.

2. Структура, содержащая характеристики числа

Выходные данные:

длина числа (кол-во цифр)

Подпрограмма итерируется по строке, пока не встретит конец (символ '\0')
проверяет, является ли символ числом и если является, то записывает в массив чисел. Так же проверяет, встретилась ли точка ('.'), как только встретилась, в характеристики записывается индекс (number->power = i). Далее, как только встречается символ 'e' (Не зависит от регистра) подпрограмма считает порядок (всё что после 'e') и записывает в характеристики числа (number->exp )

**2. exp_to_number**

int exp_to_number(char str_number[LEN], number_attributes *number)

Предназначение: 

Переводит строку чисел, записанных в экспоненциальной форме в массив чисел

Входные данные:

1. Строка, содержащая число.

2. Структура, содержащая характеристики числа

Выходные данные:

длина числа (кол-во цифр)

Подпрограмма итерируется по строке, пока не встретит конец (символ '\0')
проверяет, является ли символ числом и если является, то записывает в массив чисел. Как только встретилась '.' в характеристики записывается индекс (number->power = i).

**3. multiplication**

void multiplication(int arr1[LEN], int arr2[LEN], int len1, int len2, int arr_result[LEN])

Предназначение: 

Функция перемножения чисел.

Входные данные:

1. Первое и второе число в виде массива чисел.

2. Их длина 

3. Массив, в который будет записан результат.

Выходные данные:

Отсутствуют.

Запускается цикл по первому массиву с конца (Так же создаётся итерирующая переменная для конечного массива (результирующего), значение будет складываться из длинны первого числа + длина второго числа)
В цикле запускается второй цикл, который идёт по второму массиву (также с конца)
Каждые элементы массивов перемножаются и, если их длина больше 9 (делается якобы запоминание), то мы к следующему элементу (результирующего массива) прибавляем то, что больше 9, а текущему элементу (результирующего массива) всё что меньше 9.
По завершению цикла  итерирующая переменная для результирующего массива передвигается на следующую позицию (куда будет записываться результат следующего цикла.). Итерируемые переменные уменьшаются на единицу.
 
