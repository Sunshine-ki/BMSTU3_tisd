<h1>Отчёт:</h1>

**Задача:**

Построить дерево в соответствии с заданным вариантом задания. Вывести его
на экран в виде дерева. Реализовать основные операции работы с деревом: обход
дерева, включение, исключение и поиск узлов. Сравнить эффективность алгоритмов
сортировки и поиска в зависимости от высоты дерева и степени его ветвления.
Построить хеш-таблицу по указанным данным. Сравнить эффективность поиска в
сбалансированном двоичном дереве, в двоичном дереве поиска и в хеш-таблице.
Вывести на экран деревья и хеш-таблицу. Подсчитать среднее количество сравнений
для поиска данных в указанных структурах. Произвести реструктуризацию хеш-
таблицы, если среднее количество сравнений больше указанного.Оценить эффективность
использования этих структур (по времени и памяти) для поставленной задачи.

**Задание:**

Построить ДДП, в вершинах которого находятся слова из текстового файла.
Вывести его на экран в виде дерева. Сбалансировать полученное дерево и
вывести его на экран. Добавить указанное слово, если его нет в дереве (по
желанию пользователя) в исходное и сбалансированное дерево. Сравнить время
добавления и объем памяти. Построить хеш-таблицу из слов текстового файла,
задав размерность таблицы с экрана, используя метод цепочек для устранения
коллизий. Вывести построенную таблицу слов на экран. Осуществить
добавление введенного слова, вывести таблицу. Сравнить время добавления,
объем памяти и количество сравнений при использовании ДДП,
сбалансированных деревьев, хеш-таблиц и файла.

**Цель работы**

Реализовать операции работы с ДДП, АВЛ и хеш-таблицами

**Введение:**

Краткие характеристики:

Наименование программы: lab_06.c

Срок сдачи: 16.11.19

**Основания для разработки:**

Заказчик: Александра Васильевна Силантьева

Заказчик: Никульшина Татьяна Александровна

Исполнитель: Сукочева Элис

**Требования к программе:**

1. Задача решается на языке программирования "с".

2. При некорректном вводе пользователя выводится сообщение об ошибке и просьба ввести заново.



**Входные данные**

1. Размерность Хеш-таблицы

2. Цифры (Выбор в меню)

3. Слова.

4. Текстовый файл со словами.

**Выходные данные**

1. Хеш-таблица

2. ДДП дерево.

3. АВЛ дерево

4. Слово (которое нужно было найти)


**Структура данных.**

```

typedef struct hash_s
{
int hash_index;
char name[MAX_LEN_WORD];
struct hash_s *next;
} hash_s;

// ДДП _BINARY_SEARCH_TREE_
typedef struct bin_search_s
{
char data[MAX_LEN_WORD];
struct bin_search_s *left;
struct bin_search_s *right;
struct bin_search_s *parent;
} bin_search_s;

//АВЛ
typedef struct node_t
{
char value[MAX_LEN_WORD]; // значение в вершине
unsigned int height; // высота дерева в данной вершине
struct node_t *left;
struct node_t *right;
struct node_t *parent;
} node_t;


```

**Выбор действия**

![image](uploads/b5050c578840a7bbf8718e71e56c58cc/image.png)

**Аварийные ситуации**

При некорректном вводе

![image](uploads/7ed30a7bd7a265a461535e1c6a71a812/image.png)

При несуществующем действии

![image](uploads/333e99afa86ae7ee3fb9bc97646a2d74/image.png)

**Время работы программы**

![image](uploads/2fe654d2fb91d52a93a76fad683d4728/image.png)


**Количество сравнений**

![image](uploads/7f3c8b788a653af4cbd6d4360f6b5ce6/image.png)

**Ответы на вопросы**

1. Что такое дерево?

Дерево – это нелинейная структура данных, используемая для представления иерархических связей, имеющих отношение «один
ко многим».

2. Как выделяется память под представление деревьев?

Выделение памяти под деревья определяется типом их представления. Это может быть таблица связей с предками или связный
список сыновей. Оба представления можно реализовать в виде матрицы или списка. При реализации списком память выделяется
динамически, при реализации матрицей статически.

3. Какие стандартные операции возможны над деревьями?

Основные операции с деревьями: обход дерева, поиск по дереву, включение в дерево, исключение из дерева

4. Что такое дерево двоичного поиска?

Дерево двоичного поиска – это такое дерево, в котором все левые потомки моложе предка, а все правые – старше.

5. Чем отличается идеально сбалансированное дерево от АВЛ дерева?

Дерево, у которого число вершин в левом и правом поддеревьях отличается не более, чем на единицу называется идеально
сбалансированным. Двоичное дерево, у каждого узла которого высота двух поддеревьев отличается не более чем на единицу
называется АВЛ-деревом.

6. Чем отличается поиск в АВЛ-дереве от поиска в дереве двоичного поиска?

Поиск в АВЛ дереве имеет сложность О(log2n), в то время как в обычном ДДП сложность О(n).

7. Что такое хеш-таблица, каков принцип ее построения?

Массив, элементы в котором распределяются в зависимости от Хеш-функции.
Минимальная трудоемкость поиска в хеш-таблице равна О(1).

8. Что такое коллизии? Каковы методы их устранения.

Коллизия – ситуация, когда разным ключам соответствует одно значение хеш-функции. Существует несколько возможных
вариантов разрешения коллизий: внешнее (открытое) хеширование (метод цепочек) и внутреннее (закрытое) хеширование
(открытая адресация).


9. В каком случае поиск в хеш-таблицах становится неэффективен?

Поиск в хэш-таблице становится неэффективным при большом числе коллизий – сложность поиска возрастает.

10. Эффективность поиска в АВЛ деревьях, в дереве двоичного поиска и в хеш-
таблицах

В хэш-таблице минимальное время поиска О(1).

В АВЛ дереве О(log2n).

В дереве двоичного поиска О(h), где h – высота дерева.

**Выводы**

В этой лабораторной работе мы реализовали работу с ДДП, АВЛ деревьями и Хеш-таблицами, познакомились с коллизиями,
узнали методы их устранения и поняли, что при минимальном числе коллизий очень эффективна (и по скорости и по памяти)
Хеш-таблица. Но проблема Хеш-таблицы в том, что сложно подобрать хорошую Хеш-функцию. Подбирать Хеш-функцию нужно так,
чтобы она допускала минимальное число коллизий и быстро считала хеш. Так же поняли, что работа с АВЛ деревьями
эффективней, чем работа с ДДП.