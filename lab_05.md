<h1>Отчёт:</h1> 

**Задача:**

Система массового обслуживания состоит из обслуживающего аппарата
(ОА) и двух очередей заявок двух типов.

Заявки 1-го и 2-го типов поступают в "хвосты" своих очередей по
случайному закону с интервалами времени Т1 и Т2, равномерно
распределенными от 1 до 5 и от 0 до 3 единиц времени (е.в.) соответственно.
В ОА они поступают из "головы" очереди по одной и обслуживаются также
равновероятно за времена Т3 и Т4, распределенные от 0 до 4 е.в. и от 0 до 1
е.в. соответственно, после чего покидают систему. (Все времена –
вещественного типа) В начале процесса в системе заявок нет.
Заявка 2-го типа может войти в ОА, если в системе нет заявок 1-го типа.
Если в момент обслуживания заявки 2-го типа в пустую очередь входит заявка
1-го типа, то она ждет первого освобождения ОА и далее поступает на
обслуживание (система с относительным приоритетом ).
Смоделировать процесс обслуживания первых 1000 заявок 1-го типа.
Выдать на экран после обслуживания каждых 100 заявок 1-го типа
информацию о текущей и средней длине каждой очереди, количестве
вошедших и вышедших заявок и о среднем времени пребывания заявок в
очереди. В конце процесса выдать общее время моделирования и количество
вошедших в систему и вышедших из нее заявок обоих типов. По требованию
пользователя выдать на экран адреса элементов очереди при удалении и
добавлении элементов. Проследить, возникает ли при этом фрагментация
памяти.

**Цель работы** 

Реализовать операции работы с очередью, которая
представлена в виде массива (статического или динамического) и в виде
односвязного списка, оценить преимущества и недостатки каждой реализации,
получить представление о механизмах выделения и освобождения памяти при
работе с динамическими структурами данных.

**Введение:**

Наименование программы: lab_05.c

Краткие характеристики: Программа симулирует работу очереди

Срок сдачи: 25.10.19  

**Основания для разработки:**

Заказчик: Александра Васильевна Силантьева

Заказчик: Никульшина Татьяна Александровна

Исполнитель: Сукочева Элис

**Требования к программе:**

1. Задача решается на языке программирования "с". 

2. При некорректном вводе пользователя выводится сообщение об ошибке и просьба ввести заново.

3. При переполнении очереди (при реализации статическим массивом) выдавать сообщение, что очередь переполнена.


**Входные данные**

1. Время.

**Выходные данные**

1. После обслуживания каждых 100 заявок 1-го типа:

1. Текущая длина первой и второй очереди.

2. Кол-во вошедших в систему заявок 1-ого и 2-ого типа.

3. Кол-во вышедших из системы заявок 1-ого и 2-ого типа.

4. Cреднее время моделирования заявок 1-ого и 2-ого типа.

5. Cреднее время обслуживания заявок 1-ого и 2-ого типа.


2. В конце процесса:

1. Кол-во вошедших в систему заявок 1-ого и 2-ого типа.

2. Кол-во вышедших из системы заявок 1-ого и 2-ого типа.

3. Время моделирования заявок 1-ого типа.


**Структура данных.**

```

typedef struct list_s
{
    int data;
    struct list_s *ptr;
} list_s;

typedef struct
{
    list_s *first, *last;
} queue_s;

typedef struct
{
    int arr[MAX_LEN_ARRAY];
    int first, last;
} array_s;

typedef struct
{
    double t_list_queue1;
    double t_list_queue2;
    double t_service_unit;
    double t_expectation_1; // Время ожидания 1.
    double t_expectation_2; // Время ожидания 2.
    double t_modeling_1;    // Время моделирования заявок 1-ого типа.
    double t_modeling_2;    // Время моделирования заявок 2-ого типа.
    double t_service_1;     // Время обслуживания заявок первого типа.
    double t_service_2;     // Время обслуживания заявок второго типа.
    double delay; // Прсотой.
} time_s;

```

**Тесты**

После обслуживания каждых 100 заявок 1-го типа:

Текущая длина первой очереди 0

Средняя длина первой очереди 0

Кол-во вошедших в систему заявок 1-ого типа 100

Кол-во вышедших из системы заявок 1-ого типа 100

Cреднее время моделирования заявок 1-ого типа 3.206200

Cреднее время обслуживания заявок 1-ого типа 1.884900

Текущая длина второй очереди 12

Средняя длина второй очереди 3

Кол-во вoшедших в систему заявок 2-ого типа 205

Кол-во вышедших из системы заявок 2-ого типа 193

Cреднее время моделирования заявок 2-ого типа 1.555317

Cреднее время обслуживания заявок 1-ого типа 0.497565


В конце процесса:

Время моделирования 5197.850000

Кол-во вошедших в систему заявок 1-ого типа 1000

Кол-во вышедших из системы заявок 1-ого типа 1000

Кол-во вошедших в систему заявок 2-ого типа 2083

Кол-во вышедших из системы заявок 2-ого типа 2024

Время простоя 19.720000

**Аварийные ситуации**

1. Переполнение при реализации массивом

Пример переполнения: параметры

**Время работы программы**

При реализации списком:

Time progs 6300.000000

При реализации массивом:

Time progs 3391.000000


**Ответы на вопросы**

1. Что такое очередь?

Очередь – это последовательный список переменной длины, включение
элементов в который идет с одной стороны (с «хвоста»), а исключение – с другой
стороны (с «головы»). Принцип работы очереди: первым пришел – первым вышел, т.
е. First In – First Out (FIFO).

2. Каким образом, и какой объем памяти выделяется под хранение очереди при
различной ее реализации?

При реализации очереди в виде вектора выделяется фиксированное количество памяти.

При реализации очереди в виде списка объём памяти зависит от 
объема доступной программе оперативной памяти.

3. Каким образом освобождается память при удалении элемента из очереди при
ее различной реализации?

При реализации очереди в виде массива память освобождается при выходе из программы.

При реализации очереди в виде списка каждый раз при удалении элемента.

4. Что происходит с элементами очереди при ее просмотре?

При просмотре очереди хвостовые элементы из нее удаляются.

5. Каким образом эффективнее реализовывать очередь. От чего это зависит?

Если говорить о скорости, то эффективнее массивом, если о памяти, то зависит от того, изместно ли нам изначально кол-во
элементов.

6. В каком случае лучше реализовать очередь посредством указателей, а в
каком – массивом?

Если заранее известно кол-во элементов и оно не более чем половина выделенного места под статический массив, то массивом,иначе списком. 

7. Каковы достоинства и недостатки различных реализаций очереди в
зависимости от выполняемых над ней операций?

При реализации очереди массивом может произойти переполнение очереди, а также затрачивается дополнительное время на сдвиг элементов. При реализации очереди списком затрачивается большее количество времени при добавлении нового элемента, для хранения указателей требуется дополнительная память.

8. Что такое фрагментация памяти?

Наличие в ОЗУ большого числа коротких несмежных блоков, не позволяющее удовлетворить запрос на выделение блока большего размера.

9. На что необходимо обратить внимание при тестировании программы?

При тестировании программы необходимо обратить внимание на переполнение очереди (при реализации очереди в виде массива) и на фрагментацию (при реализации очереди в виде списка)


10. Каким образом физически выделяется и освобождается память при
динамических запросах?

Программа дает запрос ОС на выделение блока памяти необходимого размера. ОС находит подходящий блок, записывает его адрес и размер в таблицу адресов, а затем возвращает данный адрес в программу. При запросе на освобождение указанного блока программы, ОС убирает его из таблицы адресов, однако указатель на этот блок может остаться в программе. Попытка считать данные из этого блока может привести к ошибке программы или неверному результату, поскольку они могут быть уже изменены.
